#include<stdio.h>#include<stdlib.h>#include<string.h>#include<time.h>#include"buffer.h"#include"fila.h"#include"tabuleiro.h"/*Função recebe um par de coordenadas e devolve uma lista com todos deus vizinhos */Buffer *osVizinhos(cord elemtAnalizado){    cord Temp;    Buffer *listVizis;    listVizis = criaBuffer();    /*Analizando de o elemento se não se encontra na linha zero, ou seja possui     *vizinho a esquerda.     */    if(elemtAnalizado.lin > 0) {        Temp.lin = elemtAnalizado.lin - 1;        Temp.col = elemtAnalizado.col;        adicionaNoBuffer(listVizis, Temp);    }    /*Analizando de o elemento possui vizinho a direita.     */    if(elemtAnalizado.lin < 13) {        Temp.lin = elemtAnalizado.lin + 1;        Temp.col = elemtAnalizado.col;        adicionaNoBuffer(listVizis, Temp);    }    /*Analizando de o elemento possui vizinho em cima dele.     */    if(elemtAnalizado.col > 0) {        Temp.lin = elemtAnalizado.lin;        Temp.col = elemtAnalizado.col - 1;        adicionaNoBuffer(listVizis, Temp);    }    /*Analizando de o elemento possui vizinho em baixo dele.     */    if(elemtAnalizado.col < 13) {        Temp.lin = elemtAnalizado.lin;        Temp.col = elemtAnalizado.col + 1;        adicionaNoBuffer(listVizis, Temp);    }    /*Analizando se o elemento possui vizinho na diagonal inferior esquerda.     */    if(elemtAnalizado.lin > 0 && elemtAnalizado.col < 13) {        Temp.lin = elemtAnalizado.lin - 1;        Temp.col = elemtAnalizado.col + 1;        adicionaNoBuffer(listVizis, Temp);    }    /*Analizando se o elemento possui vizinho na diagonal superior direita.     */    if(elemtAnalizado.lin < 13 && elemtAnalizado.col > 0) {        Temp.lin = elemtAnalizado.lin + 1;        Temp.col = elemtAnalizado.col - 1;        adicionaNoBuffer(listVizis, Temp);    }    return listVizis;}/*Função recebe um tabuleiro e qual cor sera analizada, ela devolve 1 se a cor *tiver um caminho que liga os dois extremos e 0 caso contrario. */int fimDoJogo(tabuleiro Tab, char tipo){    int i, j;    cord Temp, vizinho;    Buffer *listVizis;    fila* Fila;    /*Para não adicionar pontos que já foram visitados iremos marcalos, assim    *iremos reiniciar a marcação deles(0 significa que não foram visitados).     */    for(i = 0; i < 14; i++)        for(j = 0; j < 14; j++)            Tab[i][j].visto = 0;    Fila = criaFila();    /*Iremos dividir o codigo para analizar se for branco ou preto, como a     *implentação não diverge muito só havera comentarios para branco.     */    if(tipo == 'b'){        /*Todas as posições da linha zero que possuem peças brancas terão seus         *vizinhos adicionados a fila.         */        for(j = 0; j < 14; j++){            if(Tab[0][j].tipo == 'b' && Tab[0][j].visto == 0){                Temp.lin = 0;                Temp.col = j;                Tab[0][j].visto = 1;                listVizis = osVizinhos(Temp);                for(i = 0; i < listVizis->top; i++){                    vizinho = listVizis->Vet[i];                    if(Tab[vizinho.lin][vizinho.col].tipo == 'b')                        insereFila(Fila, vizinho);                }                destroiBuffer(listVizis);            }        }        /*Enuqanto a fila não esta vazia há chance de que o jogo acabou.         */        while(!filaVazia(*Fila)){            Temp = removeFila(Fila);            /*Como partimos de um extremo se chegarmos a outro isso significa que             *existe um caminho ligando os dois extremos logo o jogo acabou.             */            if(Temp.lin == 13){                destroiFila(Fila);                return 1;            }            /*Caso o iten removido não esteja no outro extremo iremos colocar             *todos seus vizinhos que possuem uma peça da mesma cor na fila.             */            listVizis = osVizinhos(Temp);            for(j = 0; j < listVizis->top; j++){                vizinho = listVizis->Vet[j];                if(Tab[vizinho.lin][vizinho.col].tipo == 'b'){                    if(Tab[vizinho.lin][vizinho.col].visto == 0){                        Tab[vizinho.lin][vizinho.col].visto = 1;                        insereFila(Fila, vizinho);                    }                }            }            destroiBuffer(listVizis);        }    }    else {        for(i = 0; i < 14; i++){            if(Tab[i][0].tipo == 'p' && Tab[i][0].visto == 0){                Tab[i][0].visto = 1;                Temp.lin = i;                Temp.col = 0;                listVizis = osVizinhos(Temp);                for(j = 0; j < listVizis->top; j++){                    vizinho = listVizis->Vet[j];                    if(Tab[vizinho.lin][vizinho.col].tipo == 'b')                        insereFila(Fila, vizinho);                }                destroiBuffer(listVizis);            }        }        while(!filaVazia(*Fila)){            Temp = removeFila(Fila);            if(Temp.col == 13){                destroiFila(Fila);                return 1;            }            listVizis = osVizinhos(Temp);            for(j = 0; j < listVizis->top; j++){                vizinho = listVizis->Vet[j];                if(Tab[vizinho.lin][vizinho.col].tipo == 'p'){                    if(Tab[vizinho.lin][vizinho.col].visto == 0){                        Tab[vizinho.lin][vizinho.col].visto = 1;                        insereFila(Fila, vizinho);                    }                }            }            destroiBuffer(listVizis);        }    }    destroiFila(Fila);    return 0;}/*Função recebe um tabuleiro, a ultima jogada do adversario e sua cor, a função *ira escolher o proximo movimento a ser feito. */cord proxJogada(tabuleiro Tab, cord jogadAnt, char corInimiga){    int i,j;    Buffer *listVizis;    listVizis = osVizinhos(jogadAnt);    j = listVizis->top;    for(i = 0; i < j; i++)        /*Iremos aumentar o peso de certas posições que podem ser mais importantes.         */        if(corInimiga == 'p'){            if(listVizis->Vet[i].col == jogadAnt.col + 1)                adicionaNoBuffer(listVizis, listVizis->Vet[i]);            if(listVizis->Vet[i].col == jogadAnt.col - 1)                adicionaNoBuffer(listVizis, listVizis->Vet[i]);        }        else if(corInimiga == 'b'){            if(listVizis->Vet[i].lin == jogadAnt.lin + 1)                adicionaNoBuffer(listVizis, listVizis->Vet[i]);            if(listVizis->Vet[i].lin == jogadAnt.lin - 1)                adicionaNoBuffer(listVizis, listVizis->Vet[i]);        }    /*Agora iremos escolher um vizinho aleatorio.     */    do i = rand()%listVizis->top;    while(Tab[listVizis->Vet[i].lin][listVizis->Vet[i].col].tipo != '-');    jogadAnt = listVizis->Vet[i];    destroiBuffer(listVizis);    return jogadAnt;}int main(int argc, char **argv){    tabuleiro Tab;    char minhaCor, corInimiga;    cord jogada;    int devePrintar, meuTurno, primTurno;    if(argc < 2) {        fprintf(stderr,"Argumentos insuficientes\n");        return -1;    }    else if(strcmp(argv[1], "p") && strcmp(argv[1], "b")) {        fprintf(stderr,"Argumento tipo de peça errado!\n");        return -1;    }    else if(argc == 3 && strcmp(argv[2], "d")) {        fprintf(stderr,"Segundo argumento errado!\n");        return -1;    }    srand(time(NULL));    minhaCor = *argv[1];    if(minhaCor == 'p') corInimiga = 'b';    else corInimiga = 'p';    if(minhaCor == 'b') meuTurno = 1;    else meuTurno = 0;    if(argc == 3) devePrintar = 1;    else devePrintar = 0;    Tab = criaTab();    primTurno = 1;    while(1){        if(devePrintar) imprimeTab(Tab);        while(!meuTurno) {            if(scanf("%d%d", &jogada.lin, &jogada.col) != 2)                fprintf(stderr,"Erro ao ler jogada!\n");            else if(jogada.lin < 0 || jogada.lin > 13 || jogada.col < 0 || jogada.col > 13)                fprintf(stderr,"Jogada invalida!\n");            /*Iremos verificar se a pierule foi usada.             */            else if(primTurno == 1 && corInimiga == 'p'){                if(Tab[jogada.lin][jogada.col].tipo == minhaCor){                    minhaCor = 'p';                    corInimiga = 'b';                    primTurno = 0;                    meuTurno = 1;                }                else{                    Tab[jogada.lin][jogada.col].tipo = corInimiga;                    primTurno = 0;                    meuTurno = 1;                }            }            else{                if(Tab[jogada.lin][jogada.col].tipo != '-')                    fprintf(stderr,"Posição ocupada!\n");                else{                    Tab[jogada.lin][jogada.col].tipo = corInimiga;                    meuTurno = 1;                }            }        }        if(fimDoJogo(Tab, corInimiga)){            printf("%c ganhou\n", corInimiga);            break;        }        jogada = proxJogada(Tab, jogada, corInimiga);        Tab[jogada.lin][jogada.col].tipo = minhaCor;        printf("%d %d\n", jogada.lin, jogada.col);        meuTurno = 0;        if(fimDoJogo(Tab, minhaCor)){            printf("%c ganhou\n", minhaCor);            break;        }    }    destroiTab(Tab);    return 0;}